// Pyodide Web Worker
//
// This worker runs Pyodide with IPython display formatting loaded from
// a separate Python file, but executes user code directly through Pyodide
// to avoid IPython's code transformations. It handles serialization properly
// and provides rich output support with interrupt capabilities.

/// <reference lib="webworker" />

import { loadPyodide, type PyodideInterface } from "pyodide";

// Import Python files as text assets
import runtRuntimePy from "./runt_runtime.py?raw";
import runtRuntimeRegistryPy from "./runt_runtime_registry.py?raw";
import runtRuntimeDisplayPy from "./runt_runtime_display.py?raw";
import runtRuntimeBootstrapPy from "./runt_runtime_bootstrap.py?raw";
import runtRuntimeShellPy from "./runt_runtime_shell.py?raw";
import runtRuntimeInterruptPatchesPy from "./runt_runtime_interrupt_patches.py?raw";
import type { FileData } from "@runtimed/schema";

declare const self: DedicatedWorkerGlobalScope;

// Extend global scope for debugging
declare global {
  var pyodide: PyodideInterface | null;
}

let pyodide: PyodideInterface | null = null;
let interruptBuffer: SharedArrayBuffer | null | undefined = null;
let isShuttingDown = false;
let isBootstrapComplete = false;
let bootstrapPromise: Promise<void> | null = null;
const backgroundOperations: (() => void)[] = [];

// Global error handler for uncaught worker errors
self.addEventListener("error", (event) => {
  self.postMessage({
    type: "log",
    data: `Worker uncaught error: ${event.message}`,
  });
});

// Global handler for unhandled promise rejections
self.addEventListener("unhandledrejection", (event) => {
  // Check if this is a KeyboardInterrupt
  if (event.reason && typeof event.reason === "object") {
    const errorStr = event.reason.toString();
    if (errorStr.includes("KeyboardInterrupt")) {
      // This is expected during cancellation - prevent default handling
      // but don't send duplicate error messages since executePython handles it
      event.preventDefault();
      return;
    }
  }

  self.postMessage({
    type: "log",
    data: `Worker unhandled rejection: ${event.reason}`,
  });
});

// Handle messages from main thread
self.addEventListener("message", async (event) => {
  const { id, type, data } = (event as MessageEvent).data;

  try {
    switch (type) {
      case "init": {
        await initializePyodide(
          data.interruptBuffer,
          data.packages,
          data.mountData
        );
        self.postMessage({ id, type: "response", data: { success: true } });
        break;
      }

      case "execute": {
        const result = await executePython(data.code);
        self.postMessage({ id, type: "response", data: result });
        break;
      }

      case "sync_outputs": {
        const result = await syncOutputsToHost();
        self.postMessage({ id, type: "response", data: result });
        break;
      }

      case "get_registered_tools": {
        const result = await pyodide!.runPythonAsync(`get_registered_tools()`);
        const parsed = JSON.parse(result);
        self.postMessage({ id, type: "response", data: parsed });
        break;
      }

      case "run_registered_tool": {
        try {
          // Pass arguments as JSON string directly to registry
          pyodide!.globals.set(
            "kwargs_string",
            JSON.stringify(data.args || {})
          );
          const result = await pyodide!.runPythonAsync(
            `
await run_registered_tool("${data.toolName}", kwargs_string)
          `.trim()
          );
          self.postMessage({ id, type: "response", data: result });
        } catch (error) {
          // Send back the Python error details for debugging
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          self.postMessage({
            id,
            type: "error",
            error: errorMessage,
          });

          // Also log to console for debugging
          console.error(`Tool execution failed for ${data.toolName}:`, error);
        }
        break;
      }

      case "files": {
        if (!pyodide) {
          throw new Error("Pyodide not initialized");
        }

        try {
          // Cast the files to the expected type
          const files = data.files as readonly FileData[];

          const filesInDirectory = pyodide.FS.readdir("./");

          // Write/delete the new files
          for (const file of files) {
            if (file.deletedAt) {
              if (!filesInDirectory.includes(file.fileName)) {
                continue;
              }
              console.log("worker deleting file", { file });
              // Just in case we couldn't match the file, we want to put a try/catch
              // to avoid the worker crashing
              try {
                pyodide.FS.unlink(`./${file.fileName}`);
              } catch (error) {
                // File doesn't exist, nothing to delete
                console.log("file does not exist, skipping deletion", {
                  fileName: file.fileName,
                  error,
                });
              }
            } else {
              // For Projects-backed artifacts, use fileUrl if available (direct access)
              // Otherwise fall back to the GET endpoint (works for both R2 and Projects)
              const artifactUrl =
                file.fileUrl || `/api/artifacts/${file.artifactId}`;

              const response = await fetch(artifactUrl);

              if (!response.ok) {
                throw new Error(
                  `Failed to fetch artifact ${file.artifactId}: ${response.status} ${response.statusText}`
                );
              }

              // Handle different file types based on mimeType
              if (file.mimeType && file.mimeType.startsWith("text/")) {
                // Text files
                const content = await response.text();
                pyodide.FS.writeFile(`./${file.fileName}`, content);
              } else {
                // Binary files (images, etc.)
                const arrayBuffer = await response.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                pyodide.FS.writeFile(`./${file.fileName}`, uint8Array);
              }
            }
          }

          console.log("worker wrote files and cleaned up old files", { data });

          self.postMessage({ id, type: "response", data: { success: true } });
        } catch (error) {
          console.error("Error in files message handler", error);
          self.postMessage({
            id,
            type: "response",
            error: error instanceof Error ? error.message : String(error),
          });
        }
        break;
      }

      case "debug": {
        // Debug message handler - allows direct access to pyodide instance
        try {
          if (!pyodide) {
            throw new Error("Pyodide not initialized");
          }

          // Execute debug command
          const result = await pyodide.runPythonAsync(
            data.code || "print('Debug mode active')"
          );
          self.postMessage({
            id,
            type: "response",
            data: { result, pyodideReady: !!pyodide },
          });
        } catch (error) {
          self.postMessage({
            id,
            type: "response",
            error: error instanceof Error ? error.message : String(error),
            data: { pyodideReady: !!pyodide },
          });
        }
        break;
      }

      case "shutdown": {
        await shutdownWorker();
        self.postMessage({ id, type: "response", data: { success: true } });
        break;
      }

      default:
        throw new Error(`Unknown message type: ${type}`);
    }
  } catch (error) {
    self.postMessage({
      id,
      type: "response",
      error: error instanceof Error ? error.message : String(error),
    });
  }
});

/**
 * Initialize Pyodide with advanced IPython integration
 */
async function initializePyodide(
  buffer: SharedArrayBuffer | null | undefined,
  packagesToLoad?: string[],
  mountData?: Array<{
    hostPath: string;
    targetPath?: string;
    files: Array<{ path: string; content: Uint8Array }>;
    readonly?: boolean;
  }>
): Promise<void> {
  self.postMessage({
    type: "log",
    data: "Loading Pyodide with display support",
  });

  // Store interrupt buffer (if available)
  interruptBuffer = buffer || null;

  // Hybrid approach: local core files, CDN packages
  // Core Pyodide runtime files from local /pyodide/, packages loaded separately from CDN
  const basePackages: string[] = [];

  // Set matplotlib backend environment variable early to prevent WebWorker DOM issues
  self.postMessage({
    type: "log",
    data: "Configuring matplotlib backend for WebWorker compatibility",
  });

  // Load Pyodide with CDN packages to avoid SRI issues
  pyodide = await loadPyodide({
    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.27.7/full/",
    packages: basePackages,
    stdout: (text: string) => {
      // Log startup messages to our telemetry for debugging
      self.postMessage({
        type: "log",
        data: `[Pyodide stdout on startup]: ${text}`,
      });
      self.postMessage({
        type: "startup_output",
        data: { type: "stdout", text },
      });
    },
    stderr: (text: string) => {
      // Log startup errors to our telemetry for debugging
      self.postMessage({
        type: "log",
        data: `[Pyodide stderr on startup]: ${text}`,
      });
      self.postMessage({
        type: "startup_output",
        data: { type: "stderr", text },
      });
    },
    fsInit: async (FS, info) => {
      // Preload Python modules as proper files in the filesystem
      self.postMessage({
        type: "log",
        data: "Preloading runt_runtime modules into filesystem",
      });

      // Load all module files directly to site-packages using imported content
      const moduleFiles = {
        "runt_runtime.py": runtRuntimePy,
        "runt_runtime_registry.py": runtRuntimeRegistryPy,
        "runt_runtime_display.py": runtRuntimeDisplayPy,
        "runt_runtime_bootstrap.py": runtRuntimeBootstrapPy,
        "runt_runtime_shell.py": runtRuntimeShellPy,
        "runt_runtime_interrupt_patches.py": runtRuntimeInterruptPatchesPy,
      };

      for (const [moduleFile, moduleCode] of Object.entries(moduleFiles)) {
        try {
          FS.writeFile(`${info.sitePackages}/${moduleFile}`, moduleCode);
        } catch (error) {
          self.postMessage({
            type: "log",
            data: `Warning: Could not load ${moduleFile}: ${
              error instanceof Error ? error.message : String(error)
            }`,
          });
        }
      }

      self.postMessage({
        type: "log",
        data: "runt_runtime modules preloaded successfully",
      });
    },
  });

  // Set up interrupt buffer (if available)
  if (interruptBuffer) {
    const interruptView = new Int32Array(interruptBuffer);
    pyodide.setInterruptBuffer(interruptView);
    self.postMessage({ type: "log", data: "Interrupt buffer configured" });
  } else {
    self.postMessage({
      type: "log",
      data: "Interrupt buffer not available - continuing without interrupt support",
    });
  }

  // Expose pyodide globally for debugging
  globalThis.pyodide = pyodide;
  self.postMessage({
    type: "log",
    data: "Pyodide exposed as globalThis.pyodide for debugging",
  });

  // Create mounted directories and copy files from host
  if (mountData && mountData.length > 0) {
    self.postMessage({
      type: "log",
      data: `Mounting ${mountData.length} host directories...`,
    });

    // Ensure /mnt directory exists
    try {
      pyodide.FS.mkdirTree("/mnt");
    } catch {
      // /mnt might already exist, ignore error
    }
    for (const { hostPath, targetPath, files, readonly } of mountData) {
      try {
        // Use specified target path or create a mount point with sanitized name
        const mountPoint =
          targetPath || `/mnt/${hostPath.replace(/[^a-zA-Z0-9_-]/g, "_")}`;

        // Create the mount directory and any parent directories
        pyodide.FS.mkdirTree(mountPoint);

        // Copy all files to the virtual filesystem first
        let fileCount = 0;
        const allDirectories = new Set<string>();

        // Always track the main mount point
        allDirectories.add(mountPoint);

        for (const { path, content } of files) {
          const virtualPath = `${mountPoint}/${path}`;

          // Create parent directories if needed
          const parentDir = virtualPath.substring(
            0,
            virtualPath.lastIndexOf("/")
          );
          if (parentDir !== mountPoint) {
            try {
              pyodide.FS.mkdirTree(parentDir);

              // Track all directory components for later read-only setting
              let currentPath = mountPoint;
              const pathParts = parentDir
                .substring(mountPoint.length + 1)
                .split("/");

              for (const part of pathParts) {
                currentPath = `${currentPath}/${part}`;
                allDirectories.add(currentPath);
              }
            } catch {
              // Directory might already exist, ignore
            }
          }

          // Write the file content
          pyodide.FS.writeFile(virtualPath, content);

          // Set file as read-only if requested (files can be set read-only immediately)
          if (readonly) {
            try {
              // Use chmod to set read-only permissions (0o444 = read-only for all)
              pyodide.FS.chmod(virtualPath, 0o444);
            } catch (error) {
              // chmod might not be supported, log warning
              self.postMessage({
                type: "log",
                data: `Warning: Failed to set read-only permissions for file ${virtualPath}: ${
                  error instanceof Error ? error.message : String(error)
                }`,
              });
            }
          }

          fileCount++;
        }

        // NOW set all directories as read-only after all files have been copied
        // IMPORTANT: This must happen AFTER all files are written, otherwise we won't be able
        // to create new files in directories that are already set to read-only
        if (readonly) {
          for (const dirPath of allDirectories) {
            try {
              // Use chmod to set read-only permissions for directory (0o555 = read+execute, no write)
              pyodide.FS.chmod(dirPath, 0o555);
            } catch (error) {
              // chmod might not be supported, log warning
              self.postMessage({
                type: "log",
                data: `Warning: Failed to set read-only permissions for directory ${dirPath}: ${
                  error instanceof Error ? error.message : String(error)
                }`,
              });
            }
          }
        }

        self.postMessage({
          type: "log",
          data: `Successfully mounted '${hostPath}' at '${mountPoint}' with ${fileCount} files${
            readonly ? " (read-only)" : ""
          }`,
        });
      } catch (error) {
        self.postMessage({
          type: "log",
          data: `Warning: Failed to mount '${hostPath}': ${
            error instanceof Error ? error.message : String(error)
          }`,
        });
      }
    }
  }

  // Always create /outputs directory for syncing back to host
  try {
    pyodide.FS.mkdirTree("/outputs");
    self.postMessage({
      type: "log",
      data: "Created /outputs directory for host syncing",
    });
  } catch {
    // /outputs might already exist, ignore error
  }

  // Load our Python bootstrap file - bootstrap packages are already available
  await setupIPythonEnvironment();

  self.postMessage({
    type: "log",
    data: "Python environment setup completed",
  });

  // Switch to raw write handler for stdout to capture all bytes
  pyodide.setStdout({
    write: (buffer: Uint8Array) => {
      // Convert buffer to text
      const text = new TextDecoder().decode(buffer);

      // Send stdout immediately without coalescing to preserve newlines
      if (text) {
        self.postMessage({
          type: "stream_output",
          data: { type: "stdout", text },
        });
      }

      return buffer.length;
    },
    isatty: true,
  });

  pyodide.setStderr({
    write: (buffer: Uint8Array) => {
      // Convert buffer to text
      const text = new TextDecoder().decode(buffer);

      // Send stderr immediately without coalescing to be consistent with stdout
      if (text) {
        self.postMessage({
          type: "stream_output",
          data: { type: "stderr", text },
        });
      }

      return buffer.length;
    },
    isatty: true,
  });

  self.postMessage({
    type: "log",
    data: "Pyodide worker initialized successfully",
  });
}

/**
 * Set up IPython environment by loading the bootstrap Python file
 */
async function setupIPythonEnvironment(): Promise<void> {
  self.postMessage({
    type: "log",
    data: "Loading pseudo-IPython environment from preloaded modules",
  });

  // Load bootstrap packages from CDN to avoid SRI integrity issues
  const bootstrapPackages = ["micropip", "packaging"];

  try {
    self.postMessage({
      type: "log",
      data: `Loading micropip, packaging`,
    });

    for (const pkg of bootstrapPackages) {
      await pyodide!.loadPackage(pkg);
    }

    self.postMessage({
      type: "log",
      data: `Loading Pygments, asttokens, six, sqlite3, stack-data, traitlets, wcwidth`,
    });

    // Load IPython dependencies first
    const ipythonDeps = [
      "ipython",
      "matplotlib",
      "decorator",
      "executing",
      "asttokens",
      "six",
      "matplotlib-inline",
      "prompt_toolkit",
      "stack-data",
      "traitlets",
      "pure-eval",
      "Pygments",
      "sqlite3",
      "wcwidth",
    ];

    for (const pkg of ipythonDeps) {
      await pyodide!.loadPackage(pkg);
    }

    // Install pydantic (required by registry.py) using micropip from CDN
    await pyodide!.runPythonAsync(
      "import micropip; await micropip.install('pydantic')"
    );
  } catch (error) {
    self.postMessage({
      type: "log",
      data: `Failed to load ${JSON.stringify(bootstrapPackages)}: ${error}`,
    });
    throw error;
  }

  // Import and initialize the runt_runtime package
  await pyodide!.runPythonAsync(`
import runt_runtime
# Initialize the pseudo-IPython sandbox environment
runt_runtime.initialize_ipython_environment()
# Make shell, tool functions, and display callbacks available globally for user code execution
globals()['shell'] = runt_runtime.shell
globals()['get_registered_tools'] = runt_runtime.get_registered_tools
globals()['run_registered_tool'] = runt_runtime.run_registered_tool
globals()['tool'] = runt_runtime.tool
globals()['js_display_callback'] = runt_runtime.js_display_callback
globals()['js_execution_callback'] = runt_runtime.js_execution_callback
globals()['js_clear_callback'] = runt_runtime.js_clear_callback
`);

  self.postMessage({
    type: "log",
    data: "Pseudo-IPython environment loaded successfully from modules",
  });

  // Install micropip packages synchronously to prevent execution before bootstrap completes
  // Skip during tests to prevent execution interference
  const isTest = globalThis.location?.search?.includes("test");

  if (!isTest) {
    self.postMessage({
      type: "log",
      data: "Installing essential packages (pandas, numpy)...",
    });

    bootstrapPromise = (async () => {
      try {
        await pyodide!.runPythonAsync(
          `await runt_runtime.bootstrap_micropip_packages()`
        );
        isBootstrapComplete = true;
        if (!isShuttingDown) {
          self.postMessage({
            type: "log",
            data: "Essential packages installed successfully",
          });
        }
      } catch (error) {
        isBootstrapComplete = true; // Mark as complete even on error to avoid infinite waiting
        if (!isShuttingDown) {
          self.postMessage({
            type: "log",
            data: `Warning: Essential package installation failed: ${error}`,
          });
        }
      }
    })();
  } else {
    isBootstrapComplete = true;
    self.postMessage({
      type: "log",
      data: "Skipping micropip bootstrap during tests",
    });
  }
}

/**
 * Analyze Python code to detect required packages
 */
function analyzeRequiredPackages(code: string): string[] {
  const requiredPackages: string[] = [];
  const lines = code.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Match import statements
    const importMatch = trimmed.match(/^(?:import|from)\s+(\w+)/);
    if (importMatch) {
      const packageName = importMatch[1];

      // Map common package aliases to actual package names
      const packageMap: Record<string, string> = {
        pd: "pandas",
        np: "numpy",
        plt: "matplotlib",
        sns: "seaborn",
        sk: "scikit-learn",
        sklearn: "scikit-learn",
        bs4: "beautifulsoup4",
        PIL: "pillow",
        cv2: "opencv-python",
      };

      const actualPackage = packageMap[packageName] || packageName;

      // Only track packages we know about
      const knownPackages = [
        "pandas",
        "numpy",
        "matplotlib",
        "seaborn",
        "scipy",
        "sympy",
        "scikit-learn",
        "beautifulsoup4",
        "pillow",
        "requests",
        "lxml",
      ];

      if (knownPackages.includes(actualPackage)) {
        requiredPackages.push(actualPackage);
      }
    }
  }

  return [...new Set(requiredPackages)]; // Remove duplicates
}

/**
 * Execute Python code with rich output capture and proper serialization
 */
async function executePython(code: string): Promise<{
  result: unknown;
}> {
  if (!pyodide) {
    throw new Error("Pyodide not initialized");
  }

  // Wait for bootstrap to complete before executing user code
  if (!isBootstrapComplete && bootstrapPromise) {
    self.postMessage({
      type: "log",
      data: "Waiting for essential packages to finish loading...",
    });
    await bootstrapPromise;
  }

  // Analyze code for required packages and wait for them
  const requiredPackages = analyzeRequiredPackages(code);
  if (requiredPackages.length > 0) {
    self.postMessage({
      type: "log",
      data: `Checking availability of required packages: ${requiredPackages.join(", ")}`,
    });

    // Wait for each required package
    for (const pkg of requiredPackages) {
      try {
        const available = await pyodide.runPythonAsync(`
try:
    await runt_runtime.wait_for_package("${pkg}", 10)
    True
except:
    False
        `);

        if (!available) {
          self.postMessage({
            type: "log",
            data: `Warning: Package ${pkg} may not be available`,
          });
        }
      } catch (error) {
        self.postMessage({
          type: "log",
          data: `Warning: Failed to check package ${pkg}: ${error}`,
        });
      }
    }
  }

  // Ensure shell is available before execution (idempotent)
  await pyodide.runPythonAsync(`
# Ensure shell is available in globals - this is idempotent
import runt_runtime
if 'shell' not in globals() or shell is None:
    globals()['shell'] = runt_runtime.shell
  `);

  let result = null;
  let executionError: {
    ename: string;
    evalue: string;
    traceback: string[];
  } | null = null;

  self.postMessage({
    type: "log",
    data: "Starting Python execution with interrupt support",
  });

  try {
    // Set up JavaScript callbacks with proper serialization
    pyodide.globals.set(
      "js_display_callback",
      (
        data: unknown,
        metadata: unknown,
        transient: unknown,
        update = false
      ) => {
        try {
          // Ensure data is serializable
          const serializedData = ensureSerializable(data);
          const serializedMetadata = ensureSerializable(metadata);
          const serializedTransient = ensureSerializable(transient);

          const outputType = update ? "update_display_data" : "display_data";

          self.postMessage({
            type: "stream_output",
            data: {
              type: outputType,
              data: serializedData,
              metadata: serializedMetadata,
              transient: serializedTransient,
            },
          });

          // Don't accumulate display events in outputs array to prevent memory leak
          // Display events are already streamed via postMessage -> ExecutionContext
        } catch (error) {
          self.postMessage({
            type: "log",
            data: `Error in display callback: ${error}`,
          });
          self.postMessage({
            type: "stream_output",
            data: {
              type: "error",
              data: {
                ename: "SerializationError",
                evalue: `Error serializing display data: ${error}`,
                traceback: [String(error)],
              },
            },
          });
        }
      }
    );

    pyodide.globals.set(
      "js_execution_callback",
      (execution_count: number, data: unknown, metadata: unknown) => {
        try {
          // Ensure data is serializable
          const serializedData = ensureSerializable(data);
          const serializedMetadata = ensureSerializable(metadata);

          self.postMessage({
            type: "stream_output",
            data: {
              type: "execute_result",
              data: serializedData,
              metadata: serializedMetadata,
              execution_count,
            },
          });

          // Don't accumulate in outputs - streaming directly to ExecutionContext
        } catch (error) {
          self.postMessage({
            type: "log",
            data: `Error in execution callback: ${error}`,
          });
          self.postMessage({
            type: "stream_output",
            data: {
              type: "error",
              data: {
                ename: "SerializationError",
                evalue: `Error serializing execution result: ${error}`,
                traceback: [String(error)],
              },
            },
          });
        }
      }
    );

    pyodide.globals.set("js_clear_callback", (wait: boolean = false) => {
      try {
        self.postMessage({
          type: "stream_output",
          data: {
            type: "clear_output",
            wait: wait,
          },
        });
      } catch (error) {
        self.postMessage({
          type: "log",
          data: `Error in clear callback: ${error}`,
        });
      }
    });

    // Set up interrupt checking function for Python
    pyodide.globals.set("pyodide_check_interrupt", () => {
      if (pyodide) {
        try {
          pyodide.checkInterrupt();
        } catch (error) {
          // Log the interrupt detection and re-throw
          self.postMessage({
            type: "log",
            data: `Interrupt detected via pyodide_check_interrupt: ${error}`,
          });
          throw error;
        }
      }
    });

    // Wire up the callbacks to the shell
    await pyodide.runPythonAsync(`
# Connect our JavaScript callbacks to the IPython shell
shell.display_pub.js_callback = js_display_callback
shell.display_pub.js_clear_callback = js_clear_callback
shell.displayhook.js_callback = js_execution_callback

# Make clear_output available globally for users
from IPython.display import clear_output

# Make interrupt checking available to Python patches
import builtins
builtins.pyodide_check_interrupt = pyodide_check_interrupt
`);

    // Execute the code directly with Pyodide (no IPython transformations)
    try {
      // Check for interrupt before execution
      pyodide.checkInterrupt();

      self.postMessage({
        type: "log",
        data: "Pre-execution interrupt check passed, executing code",
      });

      try {
        // Execute the user code directly
        const rawResult = await pyodide.runPythonAsync(code);

        self.postMessage({
          type: "log",
          data: "Code execution completed successfully",
        });

        // If there's a result, format it through IPython's display system
        if (rawResult !== null && rawResult !== undefined) {
          // Store the result in Python globals and format it
          pyodide.globals.set("_pyodide_result", rawResult);
          await pyodide.runPythonAsync(`
# Format the result through IPython's displayhook for rich formatting
if '_pyodide_result' in globals():
    shell.displayhook(_pyodide_result)
    del _pyodide_result
`);
          // Don't return the result since displayhook already handled it
          result = null;
        } else {
          result = rawResult;
        }
      } catch (pythonError: unknown) {
        // Handle KeyboardInterrupt that occurs during async execution
        if (pythonError && typeof pythonError === "object") {
          const errorStr = pythonError.toString();
          if (errorStr.includes("KeyboardInterrupt")) {
            self.postMessage({
              type: "log",
              data: "KeyboardInterrupt detected during execution",
            });
            // Handle KeyboardInterrupt as execution error - don't throw
            executionError = {
              ename: "ExecutionCancelled",
              evalue: "Execution was cancelled",
              traceback: [],
            };
          } else {
            self.postMessage({
              type: "log",
              data: `Python error during execution: ${errorStr}`,
            });
            executionError = formatPythonError(pythonError);
          }
        } else {
          self.postMessage({
            type: "log",
            data: `Unknown error during execution: ${pythonError}`,
          });
          executionError = formatPythonError(pythonError);
        }
      }
    } catch (preExecutionError: unknown) {
      // Handle errors from checkInterrupt() or other pre-execution issues
      if (preExecutionError && typeof preExecutionError === "object") {
        const errorStr = preExecutionError.toString();
        if (errorStr.includes("KeyboardInterrupt")) {
          self.postMessage({
            type: "log",
            data: "KeyboardInterrupt detected before execution",
          });
          executionError = {
            ename: "ExecutionCancelled",
            evalue: "Execution was cancelled",
            traceback: [],
          };
        } else {
          self.postMessage({
            type: "log",
            data: `Pre-execution error: ${errorStr}`,
          });
          executionError = formatPythonError(preExecutionError);
        }
      } else {
        self.postMessage({
          type: "log",
          data: `Unknown pre-execution error: ${preExecutionError}`,
        });
        executionError = formatPythonError(preExecutionError);
      }
    }
  } catch (err: unknown) {
    executionError = {
      ename: "RuntimeError",
      evalue: err instanceof Error ? err.message : "Runtime execution failed",
      traceback: [
        err instanceof Error ? err.stack || err.message : String(err),
      ],
    };
  }

  // Send error if one occurred
  if (executionError) {
    self.postMessage({
      type: "stream_output",
      data: { type: "error", data: executionError },
    });
  }

  return {
    result: ensureSerializable(result),
  };
}

/**
 * Ensure data is serializable for postMessage
 */
function ensureSerializable(obj: unknown): unknown {
  if (obj === null || obj === undefined) {
    return obj;
  }

  // Handle primitive types
  if (
    typeof obj === "string" ||
    typeof obj === "number" ||
    typeof obj === "boolean"
  ) {
    return obj;
  }

  // Handle arrays
  if (Array.isArray(obj)) {
    return obj.map(ensureSerializable);
  }

  // Handle objects
  if (typeof obj === "object") {
    // Handle PyProxy objects from Pyodide
    if (obj && typeof obj === "object" && "toJs" in obj) {
      try {
        const jsObj = (obj as { toJs: () => unknown }).toJs();
        return ensureSerializable(jsObj);
      } catch {
        return String(obj);
      }
    }

    // Handle Map objects
    if (obj instanceof Map) {
      const result: Record<string, unknown> = {};
      for (const [key, value] of obj) {
        result[String(key)] = ensureSerializable(value);
      }
      return result;
    }

    // Handle Set objects
    if (obj instanceof Set) {
      return Array.from(obj).map(ensureSerializable);
    }

    // Handle regular objects
    try {
      const result: Record<string, unknown> = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = ensureSerializable(value);
      }
      return result;
    } catch {
      return String(obj);
    }
  }

  // Fallback to string representation
  return String(obj);
}

/**
 * Format Python errors with information
 */
function formatPythonError(error: unknown): {
  ename: string;
  evalue: string;
  traceback: string[];
} {
  if (!error) {
    return {
      ename: "UnknownError",
      evalue: "Unknown Python error occurred",
      traceback: ["Unknown Python error occurred"],
    };
  }

  if (error && typeof error === "object") {
    // Handle Pyodide PyProxy errors
    if ("toString" in error && typeof error.toString === "function") {
      try {
        const errorStr = error.toString();

        // Parse Python traceback format
        if (errorStr.includes("Traceback")) {
          const lines = errorStr.split("\n").filter((line) => line.trim());
          const lastLine = lines[lines.length - 1] || "";
          const match = lastLine.match(/^(\w+(?:Error)?): (.*)$/);

          if (match && match[1] && match[2]) {
            return {
              ename: match[1],
              evalue: match[2],
              traceback: lines,
            };
          }
        }

        // Handle simple error format
        if (errorStr.includes("Error:")) {
          const match = errorStr.match(/^(\w+(?:Error)?): (.*)$/);
          if (match && match[1] && match[2]) {
            return {
              ename: match[1],
              evalue: match[2],
              traceback: [errorStr],
            };
          }
        }

        return {
          ename: "PythonError",
          evalue: errorStr,
          traceback: [errorStr],
        };
      } catch {
        // Fallback if toString fails
      }
    }

    // Handle structured error objects
    if ("type" in error && "message" in error) {
      return {
        ename: String(error.type),
        evalue: String(error.message),
        traceback: [String(error.message)],
      };
    }

    if ("message" in error) {
      return {
        ename: "PythonError",
        evalue: String(error.message),
        traceback: [String(error.message)],
      };
    }
  }

  // Ultimate fallback
  const errorStr = String(error);
  return {
    ename: "PythonError",
    evalue: errorStr,
    traceback: [errorStr],
  };
}

/**
 * Extract files from /outputs directory in Pyodide FS
 */
async function syncOutputsToHost(): Promise<{
  files: Array<{ path: string; content: Uint8Array }>;
}> {
  if (!pyodide) {
    throw new Error("Pyodide not initialized");
  }

  const files: Array<{ path: string; content: Uint8Array }> = [];

  try {
    // Recursively read all files from /outputs directory
    await readOutputDirectoryRecursive("/outputs", "", files);

    self.postMessage({
      type: "log",
      data: `Extracted ${files.length} files from /outputs directory`,
    });
  } catch (error) {
    self.postMessage({
      type: "log",
      data: `Warning: Failed to read /outputs directory: ${
        error instanceof Error ? error.message : String(error)
      }`,
    });
  }

  return { files };
}

/**
 * Recursively read files from a directory in Pyodide FS
 */
async function readOutputDirectoryRecursive(
  fullPath: string,
  relativePath: string,
  files: Array<{ path: string; content: Uint8Array }>
): Promise<void> {
  if (!pyodide) {
    return;
  }

  try {
    // Check if path exists and is a directory
    const stat = pyodide.FS.stat(fullPath);
    if (!pyodide.FS.isDir(stat.mode)) {
      // It's a file, read it
      try {
        const content = pyodide.FS.readFile(fullPath);
        files.push({
          path: relativePath || fullPath.replace("/outputs/", ""),
          content: new Uint8Array(content),
        });
      } catch (error) {
        self.postMessage({
          type: "log",
          data: `Warning: Failed to read file ${fullPath}: ${
            error instanceof Error ? error.message : String(error)
          }`,
        });
      }
      return;
    }

    // It's a directory, read its contents
    const entries = pyodide.FS.readdir(fullPath);

    for (const entry of entries) {
      // Skip . and .. entries
      if (entry === "." || entry === "..") {
        continue;
      }

      const entryPath =
        fullPath === "/outputs" ? `/outputs/${entry}` : `${fullPath}/${entry}`;
      const entryRelativePath = relativePath
        ? `${relativePath}/${entry}`
        : entry;

      await readOutputDirectoryRecursive(entryPath, entryRelativePath, files);
    }
  } catch {
    // Directory might not exist or be empty, which is fine
    if (relativePath === "") {
      // Only log for the root /outputs directory
      self.postMessage({
        type: "log",
        data: `/outputs directory is empty or does not exist`,
      });
    }
  }
}

/**
 * Shutdown worker cleanly by cancelling background operations
 */
async function shutdownWorker(): Promise<void> {
  self.postMessage({
    type: "log",
    data: "Shutting down Pyodide worker...",
  });

  // Set shutdown flag to prevent new operations
  isShuttingDown = true;

  // Cancel all background operations
  for (const cancelOp of backgroundOperations) {
    try {
      cancelOp();
    } catch {
      // Ignore errors during cleanup
    }
  }
  backgroundOperations.length = 0;

  // Give more time for any in-flight operations to complete and clean up
  await new Promise((resolve) => setTimeout(resolve, 500));

  self.postMessage({
    type: "log",
    data: "Pyodide worker shutdown complete",
  });
}

// Log that worker is ready
self.postMessage({
  type: "log",
  data: "Pyodide worker ready with serialization-safe output",
});
